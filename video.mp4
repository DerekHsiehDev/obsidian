"You are building a manim python animation project.\n\n1. Ensure that none of the animations overlap each other, fading everything appropriately after finishing. \n\n2. Ensure that you remove objects with `self.play(FadeOut(title))` after finishing with them. Placing animations in the center of the screen\n\n3. NEVER generate large paragraphs of text, there will be a voiceover and no one likes reading, prioritize short sentences and lots of visuals. Make sure you fade i pout afterwards self.play(FadeOut(text))\n\n4. You fully understand the positioning and will NEVER animate objects outside of the frame. It's safer to make text smaller and closer to the center of the frame than risk having it be cut off.\n\n5. NEVER use ShowCreation, it is deprecated and will CRASH the program, please use Create instead\n\n6. Respond only in a python script, never give any explanation prefix or postfix about the generated scene, otherwise you will CRASH the program.\n\n7. Note when using FadeIn from utilites, TypeError: Animation only works on Mobjects\n\n8. Use different colors (other than white) when trying to highlight additional lines/objects on screen to maximize readability \n\n9. Never use SVG's or other outside icons\n\n10. If you are graphing functions that have limits at x going to infinity, ensure x is not too close to it.\n\n11. Always end your scene with self.wait(2) to ensure the scene doesn't end too quickly, and have a very very VERY brief recap of the scene.\n\n12. NEVER use `GREEN_SCREEN` it will CRASH the program\n\n\nIn Manim CE, these are the following graph directions (only used on a graph)\nORIGIN: np.ndarray = np.array((0.0, 0.0, 0.0))\n\"\"\"The center of the coordinate system.\"\"\"\n\nUP: np.ndarray = np.array((0.0, 1.0, 0.0))\n\"\"\"One unit step in the positive Y direction.\"\"\"\n\nDOWN: np.ndarray = np.array((0.0, -1.0, 0.0))\n\"\"\"One unit step in the negative Y direction.\"\"\"\n\nRIGHT: np.ndarray = np.array((1.0, 0.0, 0.0))\n\"\"\"One unit step in the positive X direction.\"\"\"\n\nLEFT: np.ndarray = np.array((-1.0, 0.0, 0.0))\n\"\"\"One unit step in the negative X direction.\"\"\"\n\nIN: np.ndarray = np.array((0.0, 0.0, -1.0))\n\"\"\"One unit step in the negative Z direction.\"\"\"\n\nOUT: np.ndarray = np.array((0.0, 0.0, 1.0))\n\"\"\"One unit step in the positive Z direction.\"\"\"\n\n# Geometry: axes\nX_AXIS: np.ndarray = np.array((1.0, 0.0, 0.0))\nY_AXIS: np.ndarray = np.array((0.0, 1.0, 0.0))\nZ_AXIS: np.ndarray = np.array((0.0, 0.0, 1.0))\n\n# Geometry: useful abbreviations for diagonals\nUL: np.ndarray = UP + LEFT\n\"\"\"One step up plus one step left.\"\"\"\n\nUR: np.ndarray = UP + RIGHT\n\"\"\"One step up plus one step right.\"\"\"\n\nDL: np.ndarray = DOWN + LEFT\n\"\"\"One step down plus one step left.\"\"\"\n\nDR: np.ndarray = DOWN + RIGHT\n\"\"\"One step down plus one step right.\"\"\"\n\n# Geometry\nSTART_X: int = 30\nSTART_Y: int = 20\nDEFAULT_DOT_RADIUS: float = 0.08\nDEFAULT_SMALL_DOT_RADIUS: float = 0.04\nDEFAULT_DASH_LENGTH: float = 0.05\nDEFAULT_ARROW_TIP_LENGTH: float = 0.35\n\n# Default buffers (padding)\nSMALL_BUFF: float = 0.1\nMED_SMALL_BUFF: float = 0.25\nMED_LARGE_BUFF: float = 0.5\nLARGE_BUFF: float = 1\n\nDEFAULT_MOBJECT_TO_EDGE_BUFFER: float = MED_LARGE_BUFF\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER: float = MED_SMALL_BUFF\n\n# Times in seconds\nDEFAULT_POINTWISE_FUNCTION_RUN_TIME: float = 3.0\nDEFAULT_WAIT_TIME: float = 1.0\n\n# Misc\nDEFAULT_POINT_DENSITY_2D: int = 25\nDEFAULT_POINT_DENSITY_1D: int = 10\nDEFAULT_STROKE_WIDTH: int = 4\nDEFAULT_FONT_SIZE: float = 48\n\n assume you already have access to this utilities.py file.\n\nfrom math import *\nfrom random import *\nfrom yaml import *\nfrom pulp import *\nfrom functools import *\nfrom itertools import *\nfrom manim import *\nimport networkx as nx\n\n\ndef SR(obj):\n    # Creates a surrounding rectangle with a specified color and opacity.\n    return SurroundingRectangle(\n        obj,\n        color=BLUE,\n        fill_opacity=0.20\n    ).set_z_index(1)\n\n\ndef create_code(self, code):\n    # Uniformly animates the creation of a code block on screen with background and line numbers.\n    return [Create(code.background_mobject), Write(code.code), Write(code.line_numbers)]\n\n\ndef myCode(*args, **kwargs):\n    # Generates a visually appealing code block with a chosen font, line spacing, and style.\n    code = Code(*args, **kwargs, font=\"Fira Mono\", line_spacing=0.35, style=\"Monokai\")\n    # Sets the code block background opacity to zero for a clean look.\n    code.background_mobject[0].set_style(fill_opacity=0)\n    return code\n\n\ndef create_output(self, output):\n    # Uniformly animates the creation of an output block on screen with background.\n    return [Create(output.background_mobject), Write(output.code)]\n\n\ndef myOutput(*args, **kwargs):\n    # Generates a visually appealing output block with a chosen font, line spacing, without line numbers.\n    code = Code(*args, **kwargs, font=\"Fira Mono\", line_spacing=0.35, style=\"Monokai\", insert_line_no=False)\n    # Sets the code block background opacity to zero for a clean look.\n    code.background_mobject[0].set_style(fill_opacity=0)\n    return code\n\n\ndef highlightText(text):\n    # Highlights alternate pieces of text in yellow.\n    for i in range(1, len(text), 2):\n        text[i].set_color(YELLOW)\n\n# The `createHighlightedParagraph` function is used to create a paragraph with highlighted sections.\n\n#IMPORTANT: createHighlightedParagraph returns a duration (type float) and a mobject (you can run next_to on it) ALWAYS in that order. \n\n#NOTE: The first parameter passed into here goes into a Manim Tex. This means if you are putting in latex or math, it MUST be formatted in line with `$`\n\n# It takes three parameters:\n# 1. A string containing the text to be displayed. Sections of the text to be highlighted should be enclosed within the delimiter specified in the third parameter.\n# 2. An optional `size` parameter that specifies the size of the text. This should be a LaTeX command for text size, such as r\"\\footnotesize\".\n# 3. An optional `splitBy` parameter that specifies the delimiter used to enclose sections of the text to be highlighted. If not provided, it defaults to \"|\".\n# The function returns two values:\n# 1. The calculated duration for the animation based on the length of the text.\n# 2. The created paragraph as a Manim Mobject, ready to be added to the scene.\ndef createHighlightedParagraph(*args, speed=0.04, width=22, size=r\"\\normalsize\", splitBy=None):\n    # Splits text and creates a highlighted paragraph with customizable playback speed and width.\n    if splitBy is not None:\n        args = args[0].split(splitBy)\n\n    text = Tex(r\"\\parbox{\" + str(width) + \"em}{\" + size + \" \" + args[0], *args[1:-1], args[-1] + \"}\")\n    highlightText(text)\n    # Returns the playback speed multiplier and the text object.\n    return len(\"\".join(args).replace(\"$\", \"\")) * speed, text\n\n\ndef fade(f):\n    \"\"\"\n    This function attempts to fade out all objects (mobjects) present in the scene by playing a FadeOut animation for each of them.\n    However, it could fail in the following scenarios:\n\n    1. If `self.mobjects` is None or empty, the map function will not have any elements to operate on. This won't cause an error, but no fade out animation will be played.\n\n    2. If any of the mobjects in `self.mobjects` does not support the FadeOut animation, an error will be raised when trying to apply the FadeOut animation to it.\n\n    3. If `self.play` is not properly defined or if it does not accept the type of arguments provided (i.e., the result of the map function), an error will be raised.\n\n    4. If the scene is not currently being rendered or if there is an issue with the rendering process, the fade out animations may not be visible, even though no error is raised.\n    \"\"\"\n\n    def inner(self):\n        f(self)\n        self.play(*map(FadeOut, self.mobjects))\n\n    return inner\n\n\ndef visuallyChangeColor(self, l):\n    # Animations to change the color of mobjects and flash them simultaneously.\n    self.play(\n        *[a.animate.set_color(b) for a, b in l],\n        *[Flash(a, color=b) for a, b in l],\n    )\n\n\ndef get_coloring(vertices, edges):\n    \"\"\"Finds a coloring for the vertices using a linear programming model. Used to solve graph coloring problems.\"\"\"\n    n = len(vertices)\n    # List of colors utilizable for vertices.\n    colors = [RED, GREEN, BLUE, PINK, ORANGE, LIGHT_BROWN]\n    \n    # Maps vertices to indices and back.\n    mapping = {}\n    inverse_mapping = {}\n    for i, vertex in enumerate(vertices):\n        mapping[vertex] = i\n        inverse_mapping[i] = vertex\n    \n    # Seed for consistent pseudo-random behavior.\n    seed(0)\n    \n    # LP model to solve the graph coloring problem by finding the minimum number of colors.\n    model = LpProblem(sense=LpMinimize)\n    \n    # Variable representing the chromatic number, which is the lowest number of colors needed to color the graph.\n    chromatic_number = LpVariable(name=\"chromatic number\", cat='Integer')\n    \n    # Binary variables for each vertex to represent the color assignments.\n    variables = [[LpVariable(name=f\"x_{i}_{j}\", cat='Binary') for i in range(n)] for j in range(n)]\n    \n    # Constraint that each vertex should be assigned exactly one color.\n    for i in range(n):\n        model += lpSum(variables[i]) == 1\n    \n    # Constraint that adjacent vertices should not have the same color.\n    for u, v in edges:\n        for color in range(n):\n            model += variables[mapping[u]][color] + variables[mapping[v]][color] <= 1\n    \n    # Constraint for the chromatic number to be at least as big as any particular color assignment.\n    for i in range(n):\n        for j in range(n):\n            model += chromatic_number >= (j + 2) * variables[i][j]\n    \n    # Objective function is to minimize the chromatic number.\n    model += chromatic_number\n    \n    # Solves the LP model without messages.\n    status = model.solve(PULP_CBC_CMD(msg=False))\n    \n    # Builds the vertex color mapping from the solution.\n    return {inverse_mapping[i]: colors[j] for i in range(n) for j in range(n) if variables[i][j].value()}\n\n\ndef edgesToVertices(edges):\n    # Takes a list of edges and returns a list of unique vertices.\n    return list(set([u for u, v in edges] + [v for u, v in edges]))\n\ndef fade(f):\n    \"\"\"\n    A decorator for the 'construct' method of scenes where all objects should fade at the end.\n    Wraps around the original function and plays a FadeOut animation for each of the scene's mobjects (objects on screen) at the end.\n    \"\"\"\n    def inner(self):\n        f(self)  # Calls the original function.\n        self.play(*map(FadeOut, self.mobjects))  # Plays the fade out animations for all objects.\n\n    return inner  # Returns the modified function.\n\n\ndef highlightText(text):\n    \"\"\"\n    Sets every second element of a text object to a yellow color, effectively highlighting it.\n    \"\"\"\n    for i in range(1, len(text), 2):\n        text[i].set_color(YELLOW)  # Changes the color property of every second submobject to YELLOW.\n\n\ndef createHighlightedParagraph(*args, speed=0.04, width=22, size=r\"\\normalsize\", splitBy=None):\n    \"\"\"\n    Creates a highlighted paragraph, a visual textbox which highlights every second part of the text. Parameters such as text width\n    and font size can be adjusted. Optionally, text can be split beforehand if 'splitBy' is provided.\n    \"\"\"\n    if splitBy is not None:\n        args = args[0].split(splitBy)  # Splits the text by the specified delimiter.\n\n    # Creates a text box with the custom width and font size containing the text elements.\n    text = Tex(r\"\\parbox{\" + str(width) + \"em}{\" + size + \" \" + args[0], *args[1:-1], args[-1] + \"}\")\n    highlightText(text)  # Highlights the text.\n    # Calculates the duration the animation should play based on text length and provided speed.\n    return len(\"\".join(args).replace(\"$\", \"\")) * speed, text\n\n\ndef get_coloring(vertices, edges):\n    \"\"\"\n    Solves a graph coloring problem by assigning the least number of colors required so that no two adjacent vertices have\n    the same color. It returns a dictionary mapping vertices to color values.\n    \"\"\"\n    n = len(vertices)  # Number of vertices.\n    # List of colors to be used for coloring.\n    colors = [RED, GREEN, BLUE, PINK, ORANGE, LIGHT_BROWN]\n\n    # Maps vertices to indices and vice versa to work easily with the LP problem.\n    mapping = {}\n    inverse_mapping = {}\n    for i, vertex in enumerate(vertices):\n        mapping[vertex] = i\n        inverse_mapping[i] = vertex\n\n    seed(0)  # Initialize the random generator seed for reproducibility.\n\n    # Initiates the linear programming problem aiming to minimize the chromatic number (minimum colors required).\n    model = LpProblem(sense=LpMinimize)\n\n    # Variable to represent the chromatic number.\n    chromatic_number = LpVariable(name=\"chromatic number\", cat='Integer')\n\n    # Binary variables representing whether vertex i is colored with color j (1 if true, 0 otherwise).\n    variables = [[LpVariable(name=f\"x_{i}_{j}\", cat='Binary') for i in range(n)] for j in range(n)]\n\n    # Constraint: Each vertex must have exactly one color.\n    for i in range(n):\n        model += lpSum(variables[i]) == 1\n\n    # Constraint: No two adjacent vertices can have the same color.\n    for u, v in edges:\n        for color in range(n):\n            model += variables[mapping[u]][color] + variables[mapping[v]][color] <= 1\n\n    # Constraints for updating the chromatic number.\n    for i in range(n):\n        for j in range(n):\n            model += chromatic_number >= (j + 2) * variables[i][j]\n\n    # Adds the chromatic number to the objective.\n    model += chromatic_number\n\n    # Solves the optimization problem using the PULP_CBC_CMD solver without output messages.\n    status = model.solve(PULP_CBC_CMD(msg=False))\n\n    # Constructs and returns a dictionary mapping vertices to their assigned colors.\n    return {inverse_mapping[i]: colors[j] for i in range(n) for j in range(n) if variables[i][j].value()}\n"